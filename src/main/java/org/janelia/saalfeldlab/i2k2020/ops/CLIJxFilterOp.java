package org.janelia.saalfeldlab.i2k2020.ops;

import java.util.Arrays;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import net.haesleinhuepf.clijx.faclonheavy.CLIJxPool;
import net.haesleinhuepf.clijx.faclonheavy.TileProcessor;
import org.janelia.saalfeldlab.i2k2020.util.Util;

import net.haesleinhuepf.clij.clearcl.ClearCLBuffer;
import net.haesleinhuepf.clij.converters.implementations.ClearCLBufferToRandomAccessibleIntervalConverter;
import net.haesleinhuepf.clij.converters.implementations.RandomAccessibleIntervalToClearCLBufferConverter;
import net.haesleinhuepf.clijx.CLIJx;
import net.imglib2.RandomAccessible;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.type.NativeType;
import net.imglib2.type.numeric.RealType;
import net.imglib2.util.Intervals;
import net.imglib2.view.Views;

/**
 * A cell loader that fill {@link RandomAccessibleInterval} with data that is
 * generated by CLIJx filters.
 *
 * @author Stephan Saalfeld
 * @param <T> output type
 * @param <S> source type
 */
public class CLIJxFilterOp<T extends RealType<T> & NativeType<T>, S extends RealType<S>> implements Consumer<RandomAccessibleInterval<T>> {

	protected final RandomAccessible<S> source;
	protected final long[] padding;
	protected final CLIJxPool clijxPool;
	protected final TileProcessor filter;

	public CLIJxFilterOp(
			final RandomAccessible<S> source,
			final CLIJxPool clijxPool,
			final TileProcessor filter,
			final long... padding) {

		this.source = source;
		final int n = source.numDimensions();
		if (n == padding.length)
			this.padding = padding;
		else
			this.padding = Arrays.copyOf(padding, n);
		this.clijxPool = clijxPool;
		this.filter = filter;
	}

	@SuppressWarnings("unchecked")
	@Override
	public void accept(final RandomAccessibleInterval<T> cell) {
		CLIJx clijx = clijxPool.getIdleCLIJx();
		System.out.println("Start processing on " + clijx.getGPUName() + ": " + cell);

		final RandomAccessibleIntervalToClearCLBufferConverter rai2cl = new RandomAccessibleIntervalToClearCLBufferConverter();
		rai2cl.setCLIJ(clijx.getCLIJ());

		final ClearCLBuffer input = rai2cl.convert(Views.interval(source, Intervals.expand(cell, padding)));
		final ClearCLBuffer output = clijx.create(input);

		System.out.println("input: " + input);
		System.out.println("output: " + output);

		filter.setCLIJx(clijx);
		filter.accept(input, output);

		final ClearCLBufferToRandomAccessibleIntervalConverter cl2rai = new ClearCLBufferToRandomAccessibleIntervalConverter();
		cl2rai.setCLIJ(clijx.getCLIJ());
		final RandomAccessibleInterval<T> result = cl2rai.convert(output);

		Util.copyReal(result, Views.translate(Views.zeroMin(cell), padding));

		input.close();
		output.close();

		clijxPool.setCLIJxIdle(clijx);

		System.out.println("Finished processing on " + clijx.getGPUName() + ": " + cell);
	}
}

