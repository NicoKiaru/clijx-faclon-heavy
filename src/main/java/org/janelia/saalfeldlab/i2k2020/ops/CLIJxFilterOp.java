package org.janelia.saalfeldlab.i2k2020.ops;

import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import net.haesleinhuepf.clijx.faclonheavy.CLIJxPool;
import net.haesleinhuepf.clijx.faclonheavy.TileProcessor;
import org.janelia.saalfeldlab.i2k2020.util.Util;

import net.haesleinhuepf.clij.clearcl.ClearCLBuffer;
import net.haesleinhuepf.clij.converters.implementations.ClearCLBufferToRandomAccessibleIntervalConverter;
import net.haesleinhuepf.clij.converters.implementations.RandomAccessibleIntervalToClearCLBufferConverter;
import net.haesleinhuepf.clijx.CLIJx;
import net.imglib2.RandomAccessible;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.type.NativeType;
import net.imglib2.type.numeric.RealType;
import net.imglib2.util.Intervals;
import net.imglib2.view.Views;

/**
 * A cell loader that fill {@link RandomAccessibleInterval} with data that is
 * generated by CLIJx filters. It automatically selects an idle GPU to process the tile on.
 *
 * @author Stephan Saalfeld, Robert Haase
 * @param <T> output type
 * @param <S> source type
 */
public class CLIJxFilterOp<T extends RealType<T> & NativeType<T>, S extends RealType<S>> implements Consumer<RandomAccessibleInterval<T>> {

	protected final RandomAccessible<S> source;
	protected final long[] padding;
	protected final CLIJxPool clijxPool;
	protected final Class<? extends TileProcessor> klass;

	public CLIJxFilterOp(
			final RandomAccessible<S> source,
			final CLIJxPool clijxPool,
			final Class<? extends TileProcessor> klass,
			final long... padding) {

		this.source = source;
		final int n = source.numDimensions();
		if (n == padding.length)
			this.padding = padding;
		else
			this.padding = Arrays.copyOf(padding, n);
		this.clijxPool = clijxPool;
		this.klass = klass;
	}

	@SuppressWarnings("unchecked")
	@Override
	public void accept(final RandomAccessibleInterval<T> cell) {
		// get a CLIJx instance running on one particular GPU
		CLIJx clijx = clijxPool.getIdleCLIJx();

		// push the image to the GPU
		final RandomAccessibleIntervalToClearCLBufferConverter rai2cl = new RandomAccessibleIntervalToClearCLBufferConverter();
		rai2cl.setCLIJ(clijx.getCLIJ());
		final ClearCLBuffer input = rai2cl.convert(Views.interval(source, Intervals.expand(cell, padding)));
		// create memory on GPU for result image
		final ClearCLBuffer output = clijx.create(input);

		// process the image
		TileProcessor filter = null;
		try {
			filter = klass.getDeclaredConstructor().newInstance();
		} catch (InstantiationException e) {
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		} catch (InvocationTargetException e) {
			e.printStackTrace();
		} catch (NoSuchMethodException e) {
			e.printStackTrace();
		}
		filter.setCLIJx(clijx);
		filter.accept(input, output);

		// pull the result image back
		final ClearCLBufferToRandomAccessibleIntervalConverter cl2rai = new ClearCLBufferToRandomAccessibleIntervalConverter();
		cl2rai.setCLIJ(clijx.getCLIJ());
		final RandomAccessibleInterval<T> result = cl2rai.convert(output);

		// todo: this is an additional copy-step which might not be necessary
		Util.copyReal(result, Views.translate(Views.zeroMin(cell), padding));

		// clean up
		input.close();
		output.close();
		clijxPool.setCLIJxIdle(clijx);
	}
}

